.TH BASHACKS 1 2015-11-06
.SH NAME
bashacks \- functions to hack with bash
.\"
.SH SYNOPSIS
.B bashacks
[\fB\-c\fR [\fInumber\fR|\fIcategory\fR]]
.PP
.B bh_a1z26en
.IR string
.PP
.B bh_asc2dec
.IR char
.PP
.B bh_asciitable
.PP
.B bh_asm2sc
[\fB\-f\fR \fIarch\fR]
.IR filename.s
.PP
.B bh_asmgrep
.IR regex
.IR filename
.PP
.B bh_asminfo
.IR instruction
.PP
.B bh_atbash
.IR string
.PP
.B bh_base64
.IR string
.PP
.B bh_bcdtable
.PP
.B bh_bin2dec
.IR binary ...
.PP
.B bh_bin2hex
.IR binary ...
.PP
.B bh_bin2ip
.IR binary\-ipaddr
.PP
.B bh_bin2sc
.IR binary\-file
.PP
.B bh_bkp
.IR filename
.PP
.B bh_charcalc
.IR char
.IR operator
.IR number
.PP
.B bh_dec2asc
.IR decimal
.PP
.B bh_dec2bin
.IR decimal ...
.PP
.B bh_dec2hex
.IR decimal ...
.PP
.B bh_dlsite
.IR url
.PP
.B bh_dumpmem
.IR memory\-type
.IR pid
.IR output\-filename
.PP
.B bh_findmime
[\fB\-txt\fR|\fB\-zip\fR|\fB\-exe\fR|\fB\-msi\fR]
[\fIdirectory\fR]
.PP
.B bh_get
.IR absolute\-url
.PP
.B bh_hashes
.IR filename ...
.PP
.B bh_hex2bin
.IR hexadecimal ...
.PP
.B bh_hex2dec
.IR hexadecimal ...
.PP
.B bh_hex2str
.IR hexadecimal
.PP
.B bh_hexcalc
.IR hexadecimal
.IR operator
.IR hexadecimal
.PP
.B bh_hostcalc
.IR prefix
.PP
.B bh_intel
.IR status
.PP
.B bh_ip2bin
.IR decimal\-ipaddr
.PP
.B bh_ip2geo
.IR address
.PP
.B bh_isalnum
.IR string
.PP
.B bh_isalpha
.IR string
.PP
.B bh_isascii
.IR string
.PP
.B bh_isblank
.IR string
.PP
.B bh_iscntrl
.IR string
.PP
.B bh_isdigit
.IR string
.PP
.B bh_isgraph
.IR string
.PP
.B bh_islower
.IR string
.PP
.B bh_isperlm
.IR module
.PP
.B bh_isprint
.IR string
.PP
.B bh_ispunct
.IR string
.PP
.B bh_isspace
.IR string
.PP
.B bh_isupper
.IR string
.PP
.B bh_isword
.IR string
.PP
.B bh_isxdigit
.IR string
.PP
.B bh_matrix
.PP
.B bh_md5
.IR string
.PP
.B bh_md5rename
.IR filename
.PP
.B bh_myip
.PP
.B bh_pow
.IR pow
.IR decimal
.PP
.B bh_rot
.IR displacement
.IR string
.PP
.B bh_rotall
.IR string
.PP
.B bh_sc2asm
[\fB\-m\fR \fIarch\fR]
.IR string
.PP
.B bh_shl
.IR number
.IR bit
.PP
.B bh_shr
.IR number
.IR bit
.PP
.B bh_skel_c
.PP
.B bh_skel_python
.PP
.B bh_str2hex
[\fB\-0csx\fR]
.IR string
.PP
.B bh_str2hexr
[\fB\-0csx\fR]
.IR string
.PP
.B bh_strxor
.IR key
.IR string
.PP
.B bh_unbase64
.IR string
.PP
.B bh_unmd5
.IR string
.PP
.B bh_urldecode
.IR string
.PP
.B bh_urlencode
.IR string
.PP
.B bh_utf8table
.PP
.B bh_websearch
[\fB\-g\fR]
[\fB\-s\fR \fIstring\fR]
[\fB\-p\fR \fInumber\fR]
\fB\-t\fR \fIfile\fR
\fB\-e\fR \fIfile\-ext\fR
\fB\-d\fR \fIdomain\-name\fR
.PP
.B bh_websearch
[\fB\-p\fR \fInumber\fR]
\fB\-t\fR \fImail\fR|\fIphone\fR
\fB\-d\fR \fIdomain\-name\fR
.PP
.B bh_websearch
[\fB\-p\fR \fInumber\fR]
\fB\-t\fR \fIfree\fR
\fB\-s\fR \fIstring\fR
.PP
.B bh_wgetr
.IR url
.PP
.B bh_wscan
[\fB\-i\fR \fIiface\fR]
[\fB\-model\fR|\fB\-oui\fR|\fB\-mac\fR|\fB\-wps\fR]
.PP
.B bh_xor
.IR number1
.IR number2
.PP
.B bh_xs3table
.PP
.B bh_zipmal
.IR filename
.PP
.\"
.SH FUNCTIONS
.TP
.B bh_a1z26
Encode/Decode a string with A1Z26
.TP
.B bh_asc2dec
Convert ASCII byte to decimal equivalent
.TP
.B bh_asciitable
Show ASCII table
.TP
.B bh_asm2sc
Generate shellcode based on asm file
.TP
.B bh_asmgrep
Search assembly instructions into executable binary
.TP
.B bh_asminfo
Prints on the screen the information assembly syntax
.TP
.B bh_atbash
Encode/Decode a string with Atbash
.TP
.B bh_base64
Endode a string with BASE64
.TP
.B bh_bcdtable
Show BCD (Binary\-Coded Decimal) tables
.TP
.B bh_bin2dec
Convert binary to decimal equivalent
.TP
.B bh_bin2hex
Convert binary to hexadecimal equivalent
.TP
.B bh_bin2ip
Convert an binary IP address in quad\-dotted notation to decimal equivalent
.TP
.B bh_bin2sc
Generate shellcode based on binary file
.TP
.B bh_bkp
Do a quick backup of a file
.TP
.B bh_charcalc
Perform especial calculations between characters and numbers
.TP
.B bh_dec2asc
Convert decimal to ASCII byte equivalent
.TP
.B bh_dec2bin
Convert decimal to binary equivalent
.TP
.B bh_dec2hex
Convert decimal to hexadecimal equivalent
.TP
.B bh_dlsite
Download all site
.TP
.B bh_dumpmem, bh_dumpheap, bh_dumpstack
Create file on disk with content of process memory
.TP
.B bh_findmime
Find file by mime type (e.g. exe, msi, txt, zip)
.TP
.B bh_get
Get a URL page continuous mode (only one page)
.TP
.B bh_hashes
Generate hash all files informed
.TP
.B bh_hex2bin
Convert hexadecimal to binary equivalent
.TP
.B bh_hex2dec
Convert hexadecimal to decimal equivalent
.TP
.B bh_hex2str
Convert one or more hexadecimal bytes to ASCII string
.TP
.B bh_hexcalc
Perform calculation of numbers in hexadecimal
.TP
.B bh_hostcalc
Returns the total number of hosts based on network prefix informed
.TP
.B bh_intel
Enable/Disable instructions with intel syntax
.TP
.B bh_ip2bin
Convert an decimal IP address in quad\-dotted notation to binary equivalent
.TP
.B bh_ip2geo
Approximately determine geographical location of an IP address or domain name
.TP
.B bh_isalnum
Determine whether string or char is alphanumeric
.TP
.B bh_isalpha
Determine whether string or char is alphabetic
.TP
.B bh_isascii
Determine whether string or char is ASCII
.TP
.B bh_isblank
Determine whether string or char is blank
.TP
.B bh_iscntrl
Determine whether string or char is control
.TP
.B bh_isdigit
Determine whether string or char is decimal digit
.TP
.B bh_isgraph
Determine whether string or char is graphic
.TP
.B bh_islower
Determine whether string or char is lowercase
.TP
.B bh_isperlm
Return true or false in an attempt to detect perl module name
.TP
.B bh_isprint
Determine whetder string or char is printable
.TP
.B bh_ispunct
Determine whether string or char is punctuation
.TP
.B bh_isspace
Determine whether string or char is space
.TP
.B bh_isupper
Determine whether string or char is uppercase
.TP
.B bh_isword
Determine whether string or char is word
.TP
.B bh_isxdigit
Determine whether string or char is hexadecimal digit
.TP
.B bh_matrix
Matrix because is fun
.TP
.B bh_md5
Calculate the MD5 hash of a string or a file if it exists
.TP
.B bh_md5rename
Generate md5 message digest to one or more files and rename it with result
.TP
.B bh_myip
Show external IP address
.TP
.B bh_pow
Raise a number to a power
.TP
.B bh_rot, bh_rot5, bh_rot13
Encrypt/Decrypt string with rotation in the alphabet using n shifts to the right
.TP
.B bh_rotall
Encrypt/Decrypt string with rotation in the alphabet using all (1\-25) shifts to the right
.TP
.B bh_sc2asm
Generate asm code based on shellcode
.TP
.B bh_shl
Push bits to the left by a number
.TP
.B bh_shr
Push bits to the right by a number
.TP
.B bh_skel_c
Show the basic structure of a C code
.TP
.B bh_skel_python
Show the basic structure of a Python code
.TP
.B bh_str2hex
Convert string to hexadecimal bytes equivalent to each char
.TP
.B bh_str2hexr
Convert string to hexadecimal bytes equivalent to each char in reverse order
.TP
.B bh_strxor
Calculate exclusive OR of each character in a string with a key
.TP
.B bh_unbase64
Decode a string with BASE64
.TP
.B bh_unmd5
Attempt to discover the string that generated the MD5 hash
.TP
.B bh_urlencode
Encode a string with URL Encoding
.TP
.B bh_urldecode
Decode a string with URL Encoding
.TP
.B bh_utf8table
Show UTF8 table
.TP
.B bh_websearch
Use google base to extract information
.TP
.B bh_wgetr
Get a URL page recursive and continuous mode.
.TP
.B bh_wscan
Display the list of wireless networks with chanell, bss, signal, ssid and more
.TP
.B bh_xor
Calculate exclusive OR between two numbers
.TP
.B bh_xs3table
Show Excess\-3 table
.TP
.B bh_zipmal
Compress file in zip format with password "virus"
.\"
.SH EXAMPLE
Encode a string with A1Z26:
.PP
.nf
.RS 4
$ bh_a1z26 "www.duckduckgo.com"
23\-23\-23.4\-21\-3\-11\-4\-21\-3\-11\-7\-15.3\-15\-13
$
.RE
.fi
.PP
Convert a ASCII char in a decimal code:
.PP
.nf
.RS 4
$ bh_asc2dec A
65
$
.RE
.fi
.PP
Show the ASCII table:
.PP
.nf
.RS 4
$ bh_asciitable
Dec Hex    Dec Hex    Dec Hex  Dec Hex  Dec Hex  Dec Hex   Dec Hex   Dec Hex
  0 00 NUL  16 10 DLE  32 20    48 30 0  64 40 @  80 50 P   96 60 `  112 70 p
  1 01 SOH  17 11 DC1  33 21 !  49 31 1  65 41 A  81 51 Q   97 61 a  113 71 q
  2 02 STX  18 12 DC2  34 22 "  50 32 2  66 42 B  82 52 R   98 62 b  114 72 r
  3 03 ETX  19 13 DC3  35 23 #  51 33 3  67 43 C  83 53 S   99 63 c  115 73 s
  4 04 EOT  20 14 DC4  36 24 $  52 34 4  68 44 D  84 54 T  100 64 d  116 74 t
  5 05 ENQ  21 15 NAK  37 25 %  53 35 5  69 45 E  85 55 U  101 65 e  117 75 u
  6 06 ACK  22 16 SYN  38 26 &  54 36 6  70 46 F  86 56 V  102 66 f  118 76 v
  7 07 BEL  23 17 ETB  39 27 '  55 37 7  71 47 G  87 57 W  103 67 g  119 77 w
  8 08 BS   24 18 CAN  40 28 (  56 38 8  72 48 H  88 58 X  104 68 h  120 78 x
  9 09 HT   25 19 EM   41 29 )  57 39 9  73 49 I  89 59 Y  105 69 i  121 79 y
 10 0A LF   26 1A SUB  42 2A *  58 3A :  74 4A J  90 5A Z  106 6A j  122 7A z
 11 0B VT   27 1B ESC  43 2B +  59 3B ;  75 4B K  91 5B [  107 6B k  123 7B {
 12 0C FF   28 1C FS   44 2C ,  60 3C <  76 4C L  92 5C \\  108 6C l  124 7C |
 13 0D CR   29 1D GS   45 2D \-  61 3D =  77 4D M  93 5D ]  109 6D m  125 7D }
 14 0E SO   30 1E RS   46 2E .  62 3E >  78 4E N  94 5E ^  110 6E n  126 7E ~
 15 0F SI   31 1F US   47 2F /  63 3F ?  79 4F O  95 5F _  111 6F o  127 7F DEL
$
.RE
.fi
.PP
Generate a shellcode from an asm source file (nasm is required):
.PP
.nf
.RS 4
$ echo \-ne "xor eax, eax\\ninc eax\\ninc eax\\nint 0x80\\njmp 0x0" > fork.asm
$ bh_asm2sc fork.asm
\\x31\\xc0\\x40\\x40\\xcd\\x80\\xeb\\xf8
$
.RE
.fi
.PP
Search instruction into binary and look what exists around:
.PP
.nf
.RS 4
$ bh_asmgrep 'push.*rbp$' /bin/ls
  402dd2:	41 56                	push   %r14
  402dd4:	41 55                	push   %r13
  402dd6:	41 54                	push   %r12
  402dd8:	49 89 f4             	mov    %rsi,%r12
  402ddb:	55                   	push   %rbp
  402ddc:	89 fd                	mov    %edi,%ebp
  402dde:	53                   	push   %rbx
  402ddf:	48 81 ec 98 03 00 00 	sub    $0x398,%rsp
  402de6:	48 8b 3e             	mov    (%rsi),%rdi
\-\-passage omitted\-\-
$
.RE
.fi
.PP
Search assembly instruction, it has a caching mechanism to facilitate faster subsequent queries making (Internet connection is required):
.PP
.nf
.RS 4
$ bh_asminfo add
ADD
.PP
|Code    |Mnemonic        |Description                    |
|04 ib   |ADD AL, imm8    |Add imm8 to AL                 |
|05 iw   |ADD AX, imm16   |Add imm16 to AX                |
|05 id   |ADD EAX, imm32  |Add imm32 to EAX               |
|80 /0 ib|ADD r/m8, imm8  |Add imm8 to r/m8               |
|81 /0 iw|ADD r/m16, imm16|Add imm16 to r/m16             |
|81 /0 id|ADD r/m32, imm32|Add imm32 to r/m32             |
|83 /0 ib|ADD r/m16, imm8 |Add sign\-extended imm8 to r/m16|
|83 /0 ib|ADD r/m32, imm8 |Add sign\-extended imm8 to r/m32|
|00 / r  |ADD r/m8, r8    |Add r8 to r/m8                 |
|01 / r  |ADD r/m16, r16  |Add r16 to r/m16               |
|01 / r  |ADD r/m32, r32  |Add r32 to r/m32               |
|02 / r  |ADD r8, r/m8    |Add r/m8 to r8                 |
|03 / r  |ADD r16, r/m16  |Add r/m16 to r16               |
|03 / r  |ADD r32, r/m32  |Add r/m32 to r32               |
.PP
Description
Adds the first operand (destination operand) and the second operand (source
operand) and stores the result in the destination operand. The destination
operand can be a register or a memory location; the source operand can be an
immediate, a register, or a memory location. (However, two memory operands
cannot be used in one instruction.) When an immediate value is used as an
operand, it is sign-extended to the length of the destination operand format.
.PP
The ADD instruction does not distinguish between signed or unsigned operands.
Instead, the processor evaluates the result for both data types and sets the OF
and CF flags to indicate a carry in the signed or unsigned result,
respectively. The SF flag indicates the sign of the signed result.
.PP
|Operands|Bytes                |Clocks                                        |
|reg, reg|2                    |1|UV                                          |
|mem, reg|2 + d(0, 2)          |3|UV                                          |
|reg, mem|2 + d(0, 2)          |2|UV                                          |
|reg, imm|2 + i(1, 2)          |1|UV                                          |
|mem, imm|2 + d(0, 2) + i(1, 2)|3|UV ( not pairable if there is a displacement|
|        |                     | |and immediate)                              |
|acc, imm|1 + i(1, 2)          |1|UV                                          |
.PP
Flags
.PP
|ID  |unaffected                   |DF|unaffected                   |
|VIP |unaffected                   |IF|unaffected                   |
|VIF |unaffected                   |TF|unaffected                   |
|AC  |unaffected                   |SF|sets according to the result.|
|VM  |unaffected                   |ZF|sets according to the result.|
|RF  |unaffected                   |AF|sets according to the result.|
|NT  |unaffected                   |PF|sets according to the result.|
|IOPL|unaffected                   |CF|sets according to the result.|
|OF  |sets according to the result.|
$
.RE
.fi
.PP
Encode/Decode a string with Atbash:
.PP
.nf
.RS 4
$ bh_atbash "Hello Joshua"
Svool Qlhsfz
$ bh_atbash "Svool Qlhsfz"
Hello Joshua
$
.RE
.fi
.PP
Encode a string with BASE64:
.PP
.nf
.RS 4
$ bh_base64 'Saluton Mondo!'
U2FsdXRvbiBNb25kbyEK
$
.RE
.fi
.PP
Show the BCD table:
.PP
.nf
.RS 4
$ bh_bcdtable
Dec  XS3   8421  7421  2421  84\-2\-1    ASCII     EBCDIC
  0  0011  0000  0000  0000   0000   0011 0000  1111 0000
  1  0100  0001  0001  0001   0111   0011 0001  1111 0001
  2  0101  0010  0010  0010   0110   0011 0010  1111 0010
  3  0110  0011  0011  0011   0101   0011 0011  1111 0011
  4  0111  0100  0100  0100   0100   0011 0100  1111 0100
  5  1000  0101  0101  1011   1011   0011 0101  1111 0101
  6  1001  0110  0110  1100   1010   0011 0110  1111 0110
  7  1010  0111  1000  1101   1001   0011 0111  1111 0111
  8  1011  1000  1001  1110   1000   0011 1000  1111 1000
  9  1100  1001  1010  1111   1111   0011 1001  1111 1001
.PP
Hex 8421 Sign
  A 1010   +
  B 1011   \-
  C 1100   +
  D 1101   \-
  E 1110   +
  F 1111   +  (Unsigned)
.PP
*XS3: Stibitz Code (Excess\-3)
*2421: Aiken Code
*ASCII Zone: 0011
*EBCDIC Zone: 1111
$
.RE
.fi
.PP
Convert binary to decimal:
.PP
.nf
.RS 4
$ bh_bin2dec 11000000 10101000 100000000000
192 168 2048
$
.RE
.fi
.PP
Convert binary to hexadecimal:
.PP
.nf
.RS 4
$ bh_bin2hex 11000000 10101000 100000000000
C0 A8 800
$
.RE
.fi
.PP
Convert binary IP address to decimal:
.PP
.nf
.RS 4
$ bh_bin2ip 00001010.00000000.00000000.11001000
10.0.0.200
$
.RE
.fi
.PP
Generate shellcode from a binary file:
.PP
.nf
.RS 4
$ echo \-ne "xor eax, eax\\ninc eax\\nint 0x80" > exit.asm
$ nasm \-f elf exit.asm
$ ld \-m elf_i386 exit.o \-o exit.out
$ bh_bin2sc exit.out
\\x31\\xc0\\x40\\xcd\\x80
$
.RE
.fi
.PP
Create backup of file with 'filename.date +%Y%m%d':
.PP
.nf
.RS 4
$ bh_bkp bashacks.sh
$ ls bashacks.sh*
bashacks.sh  bashacks.sh.20141209
$
.RE
.fi
.PP
Perform calculations with strings, char and digits:
.PP
.nf
.RS 4
$ bh_charcalc f + 2
h
$ bh_charcalc B \- 1
A
$ bh_charcalc A \\* 16
AAAAAAAAAAAAAAAA
$ bh_charcalc isso \\* 3
issoissoisso
$
.RE
.fi
.PP
Convert a decimal code in a ASCII char:
.PP
.nf
.RS 4
$ bh_dec2asc 65
A
$
.RE
.fi
.PP
Convert decimal to binary:
.PP
.nf
.RS 4
$ bh_dec2bin 192 168 2048
11000000 10101000 100000000000
$
.RE
.fi
.PP
Convert decimal to hexadecimal:
.PP
.nf
.RS 4
$ bh_dec2hex 192 168 2048
C0 A8 800
$
.RE
.fi
.PP
Download all content of web site with interval randomized:
.PP
.nf
.RS 4
$ bh_dlsite www.google.com.br
\-\-passage omitted\-\-
$
.RE
.fi
.PP
Extract the contents of a process memory area (root is required):
.PP
.nf
.RS 4
# bh_dumpmem stack 15125 stack.dump
# bh_dumpmem heap 15125 heap.dump
#
.PP
or
.PP
# bh_dumpstack 15125 stack.dump
# bh_dumpheap 15125 heap.dump
#
.RE
.fi
.PP
Search files by mime type (txt, zip, exe, msi):
.PP
.nf
.RS 4
$ bh_findmime \-txt
bashacks.sh
bh\-referencia.html
Makefile
README.md
$ bh_findmime \-exe ~/Downloads
/home/bashacks/Downloads//putty.exe
$
.RE
.fi
.PP
Download absolute URL page in continuos mode:
.PP
.nf
.RS 4
$ bh_get http://www.mentebinaria.com.br/artigos/0x1f/0x1f\-maqengrevlnx.html
\-\-passage omitted\-\-
$ ls \-1
0x1f\-maqengrevlnx.html
$
.RE
.fi
.PP
Generate hash of file or list of file:
.PP
.nf
.RS 4
$ bh_hashes bashacks.sh README.md
1fca0b44a77773ca1ec4976081cc60f1  bashacks.sh
72e90888fc6b221729e3388582726dcb00522790  bashacks.sh
0fcedfc1590f34182a08a006ed46f12fb30d3fb8e0399a2cab91e78783497af7  bashacks.sh
89bbf9c8c9af65e5d91c9702c2e1663c  README.md
0adb9ba49680dd35c2d9d5a6ecf5bd86dc547f18  README.md
54b9d1d4a0278871e727c009687f0889b53ba2c280b49af82b97b4e6064b0c80  README.md
$
.RE
.fi
.PP
Convert hexdecimal to binary:
.PP
.nf
.RS 4
$ bh_hex2bin C0 a8 800
11000000 10101000 100000000000
$ bh_hex2bin 0xC0 0xa8 0x800
11000000 10101000 100000000000
$
.RE
.fi
.PP
Convert hexadecimal to decimal:
.PP
.nf
.RS 4
$ bh_hex2dec C0 a8 800
192 168 2048
$ bh_hex2dec 0xC0 0xa8 0x800
192 168 2048
$
.RE
.fi
.PP
Convert hexadecimal to string:
.PP
.nf
.RS 4
$ bh_hex2str '72 6f 63 6b 20 6e 27 20 72 6f 6c 6c'
rock n' roll
$ bh_hex2str '0x72 0x6f 0x63 0x6b 0x20 0x6e 0x27 0x20 0x72 0x6f 0x6c 0x6c'
rock n' roll
$ bh_hex2str '{0x72, 0x6f, 0x63, 0x6b, 0x20, 0x6e, 0x27, 0x20, 0x72, 0x6f, 0x6c, 0x6c}'
rock n' roll
$ bh_hex2str '0x726f636b206e2720726f6c6c'
rock n' roll
$ bh_hex2str '\\x72\\x6f\\x63\\x6b\\x20\\x6e\\x27\\x20\\x72\\x6f\\x6c\\x6c'
rock n' roll
$
.RE
.fi
.PP
Perform calculations with hexdecimal digits:
.PP
.nf
.RS 4
$ bh_hexcalc 5f \\* 2
0xBE
$ bh_hexcalc 0xdead / 0xdead
0x1
$
.RE
.fi
.PP
Calculate the amount of host on a network:
.PP
.nf
.RS 4
$ bh_hostcalc 24
254
$
.RE
.fi
.PP
Enable/Disable intel interpreter for assembly instructions:
.PP
.nf
.RS 4
$ bh_intel on
$ bh_intel off
$
.RE
.fi
.PP
Convert decimal IP address to binary:
.PP
.nf
.RS 4
$ bh_ip2bin 192.168.0.1
11000000.10101000.00000000.00000001
$
.RE
.fi
.PP
Determine the approximate geographical location of a network address:
.PP
.nf
.RS 4
$ bh_ip2geo 203.0.113.146
Operator FastConnection BR \-20 \-50 1
$
.RE
.fi
.PP
Determine whether string or char is alphanumeric:
.PP
.nf
.RS 4
$ bh_isalnum "aZ7"; echo $?
0
$ bh_isalnum "aZ7_"; echo $?
1
$ if $(bh_isalnum a) ; then echo 'OK' ; else echo 'NO' ; fi
OK
$
.RE
.fi
.PP
Determine whether string or char is alphabetic:
.PP
.nf
.RS 4
$ bh_isalpha "aZ"; echo $?
0
$ bh_isalpha "aZ7"; echo $?
1
$ if $(bh_isalpha a) ; then echo 'OK' ; else echo 'NO' ; fi
OK
$
.RE
.fi
.PP
Determine whether string or char is ASCII:
.PP
.nf
.RS 4
$ bh_isascii "$(echo \-en "\\x48\\x61\\x63\\x6b\\x65\\x72")"; echo $?
0
$ bh_isascii "$(echo \-en "\\x48\\x61\\x63\\x6b\\x65\\x72\\x80")"; echo $?
2
$ if $(bh_isascii a) ; then echo 'OK' ; else echo 'NO' ; fi
OK
$
.RE
.fi
.PP
Determine whether string or char is blank:
.PP
.nf
.RS 4
$ bh_isblank "$(echo \-en "\\t ")"; echo $?
0
$ bh_isblank "$(echo \-en "\\t \\r")"; echo $?
1
$ if $(bh_isblank a) ; then echo 'OK' ; else echo 'NO' ; fi
NO
$
.RE
.fi
.PP
Determine whether string or char is control:
.PP
.nf
.RS 4
$ bh_iscntrl "$(echo \-en "\\t\\v\\f\\r\\a")"; echo $?
0
$ bh_iscntrl "$(echo \-en "\\t\\v\\f\\r\\a ")"; echo $?
1
$ if $(bh_iscntrl a) ; then echo 'OK' ; else echo 'NO' ; fi
NO
$
.RE
.fi
.PP
Determine whether string or char is decimal digit:
.PP
.nf
.RS 4
$ bh_isdigit "379009"; echo $?
0
$ bh_isdigit "379009google"; echo $?
1
$ if $(bh_isdigit a) ; then echo 'OK' ; else echo 'NO' ; fi
NO
$
.RE
.fi
.PP
Determine whether string or char is graphic:
.PP
.nf
.RS 4
$ bh_isgraph "0@P_p~"; echo $?
0
$ bh_isgraph "0@P_p~ "; echo $?
1
$ if $(bh_isgraph a) ; then echo 'OK' ; else echo 'NO' ; fi
OK
$
.RE
.fi
.PP
Determine whether string or char is lowercase:
.PP
.nf
.RS 4
$ bh_islower "abc"; echo $?
0
$ bh_islower "abcA"; echo $?
1
$ if $(bh_islower a) ; then echo 'OK' ; else echo 'NO' ; fi
OK
$
.RE
.fi
.PP
Detect whether exist perl module:
.PP
.nf
.RS 4
$ bh_isperlm LWP
yes
$ bh_isperlm x
no
$
.RE
.fi
.PP
Determine whetder string or char is printable:
.PP
.nf
.RS 4
$ bh_isprint "$(echo \-en "0@P_p~ ")"; echo $?
0
$ bh_isprint "$(echo \-en "0@P_p~ \\x1f")"; echo $?
1
$ if $(bh_isprint a) ; then echo 'OK' ; else echo 'NO' ; fi
OK
$
.RE
.fi
.PP
Determine whether string or char is punctuation:
.PP
.nf
.RS 4
$ bh_ispunct "][\\!\\"#$%&'()*+,./:;<=>?@\^_\\`{|}~\-"; echo $?
0
$ bh_ispunct "][\\!\\"#$%&'()*+,./:;<=>?@\^_\\`{|}~\-A"; echo $?
1
$ if $(bh_ispunct a) ; then echo 'OK' ; else echo 'NO' ; fi
NO
$
.RE
.fi
.PP
Determine whether string or char is space:
.PP
.nf
.RS 4
$ bh_isspace "$(echo \-en "\\t\\v\\f\\r ")"; echo $?
0
$ bh_isspace "$(echo \-en "\\t\\v\\f\\r A")"; echo $?
1
$ if $(bh_isspace a) ; then echo 'OK' ; else echo 'NO' ; fi
NO
$
.RE
.fi
.PP
Determine whether string or char is uppercase:
.PP
.nf
.RS 4
$ bh_isupper "ABC"; echo $?
0
$ bh_isupper "ABCa"; echo $?
1
$ if $(bh_isupper a) ; then echo 'OK' ; else echo 'NO' ; fi
NO
$
.RE
.fi
.PP
Determine whether string or char is word:
.PP
.nf
.RS 4
$ bh_isword "aZ7_"; echo $?
0
$ bh_isword "aZ7_*"; echo $?
1
$ if $(bh_isword a) ; then echo 'OK' ; else echo 'NO' ; fi
OK
$
.RE
.fi
.PP
Determine whether string or char is hexadecimal digit:
.PP
.nf
.RS 4
$ bh_isxdigit "C00fee"; echo $?
0
$ bh_isxdigit "C00feeG"; echo $?
1
$ if $(bh_isxdigit a) ; then echo 'OK' ; else echo 'NO' ; fi
OK
$
.RE
.fi
.PP
FUNNY Matrix:
.PP
.nf
.RS 4
$ bh_matrix
\-\-passage omitted\-\-
^C
$
.RE
.fi
.PP
Generate MD5 without line break:
.PP
.nf
.RS 4
$ bh_md5 '123456'
e10adc3949ba59abbe56e057f20f883e
$ bh_md5 /etc/passwd
18186ca65c92ba40cfe8ed4089496c42
$
.RE
.fi
.PP
Rename one or more files with MD5 message digest generated by itself.
.PP
.nf
.RS 4
$ bh_md5 bashacks.sh
b99a81de3a206738f1339a091b81194c
$ bh_md5 README.md
6e4d6dd3ce60df996606f5b3145692f7
$ bh_md5rename bashacks.sh README.md
$ ls \-1
6e4d6dd3ce60df996606f5b3145692f7
b99a81de3a206738f1339a091b81194c
$
.RE
.fi
.PP
Show external IP address (Internet connection is required):
.PP
.nf
.RS 4
$ bh_myip
203.0.113.146
$
.RE
.fi
.PP
Ever wondered how to make power of calculation in bash, it's actually quite simple, but we simplify more:
.PP
.nf
.RS 4
$ bh_pow 8 2
64
$ bh_pow 0xa 3
1000
$
.RE
.fi
.PP
Encrypt/Decrypt string with rotation in the alphabet:
.PP
.nf
.RS 4
$ bh_rot 3 green
juhhq
$ bh_rot5 green
lwjjs
$ bh_rot13 green
terra
$ bh_rot13 terra
green
$
.RE
.fi
.PP
Perform all possible rotations (1..25) in the alphabet:
.PP
.nf
.RS 4
$ bh_rotall urfn
ROT1 vsgo
ROT2 wthp
ROT3 xuiq
ROT4 yvjr
ROT5 zwks
ROT6 axlt
ROT7 bymu
ROT8 cznv
ROT9 daow
ROT10 ebpx
ROT11 fcqy
ROT12 gdrz
ROT13 hesa
ROT14 iftb
ROT15 jguc
ROT16 khvd
ROT17 liwe
ROT18 mjxf
ROT19 nkyg
ROT20 olzh
ROT21 pmai
ROT22 qnbj
ROT23 rock
ROT24 spdl
ROT25 tqem
$
.RE
.fi
.PP
Generate a asm code from a shellcode (yes, it is wonderful):
.PP
.nf
.RS 4
$ bh_sc2asm '\\x31\\xc0\\x40\\x40\\xcd\\x80\\xeb\\xf8'
xor eax, eax
inc eax
inc eax
int 0x80
jmp 0x0
$
.RE
.fi
.PP
Move bits to left:
.PP
.nf
.RS 4
$ bh_shl 4 1
8
$ bh_shl 0x4 1
8
$
.RE
.fi
.PP
Move bits to right:
.PP
.nf
.RS 4
$ bh_shr 4 1
2
$ bh_shr 0x4 1
2
$
.RE
.fi
.PP
Generate the basic structure of a C code:
.PP
.nf
.RS 4
$ bh_skel_c
#include <stdio.h>
.PP
int main(int argc, char *argv[]) {
.PP
	return 0;
}
$
.RE
.fi
.PP
Generate the basic structure of a Python code:
.PP
.nf
.RS 4
$ bh_skel_python
#!/usr/bin/env python
# *\-* coding: utf\-8 *\-*
.PP
if __name__ == __main__:
.PP
$
.RE
.fi
.PP
Convert string to hexadecimal:
.PP
.nf
.RS 4
$ bh_str2hex 'Fernando'
46 65 72 6e 61 6e 64 6f
$ bh_str2hex \-0 'Fernando'
0x46 0x65 0x72 0x6e 0x61 0x6e 0x64 0x6f
$ bh_str2hex \-c 'Fernando'
{0x46, 0x65, 0x72, 0x6e, 0x61, 0x6e, 0x64, 0x6f}
$ bh_str2hex \-s 'Fernando'
0x4665726e616e646f
$ bh_str2hex \-x 'Fernando'
\\x46\\x65\\x72\\x6e\\x61\\x6e\\x64\\x6f
$
.RE
.fi
.PP
Convert reverse string to hexadecimal:
.PP
.nf
.RS 4
$ bh_str2hexr 'Fernando'
6f 64 6e 61 6e 72 65 46
$ bh_str2hexr \-0 'Fernando'
0x6f 0x64 0x6e 0x61 0x6e 0x72 0x65 0x46
$ bh_str2hexr \-c 'Fernando'
{0x6f, 0x64, 0x6e, 0x61, 0x6e, 0x72, 0x65, 0x46}
$ bh_str2hexr \-s 'Fernando'
0x6f646e616e726546
$ bh_str2hexr \-x 'Fernando'
\\x6f\\x64\\x6e\\x61\\x6e\\x72\\x65\\x46
$
.RE
.fi
.PP
Calculate exclusive OR of each char, uses decimal or hexadecimal for key:
.PP
.nf
.RS 4
$ bh_strxor 4 'ieikjew$ewwewwmjew'
mamonas assassinas
$
.RE
.fi
.PP
Encode a string with BASE64:
.PP
.nf
.RS 4
$ bh_unbase64 'U2FsdXRvbiBNb25kbyEK'
Saluton Mondo!
$
.RE
.fi
.PP
Attempt to discover the string that generated the MD5 hash (Internet connection is required):
.PP
.nf
.RS 4
$ bh_unmd5 827ccb0eea8a706c4c34a16891f84e7b
12345
$
.RE
.fi
.PP
Encode string with URL Encoding:
.PP
.nf
.RS 4
$ bh_urlencode "/zzz=anything' OR 'x'='x"
%2fzzz%3danything%27%20OR%20%27x%27%3d%27x
$
.RE
.fi
.PP
Decode a string with URL Encoding
.PP
.nf
.RS 4
$ bh_urldecode "%2fzzz%3danything%27%20OR%20%27x%27%3d%27x"
/zzz=anything' OR 'x'='x
$
.RE
.fi
.PP
Show the UTF\-8 table:
.PP
.nf
.RS 4
$ bh_utf8table
Hex      Hex      Hex      Hex      Hex      Hex      Hex      Hex
c2 a0    c2 ac ¬  c2 b8 ¸  c3 84 Ä  c3 90 Ð  c3 9c Ü  c3 a8 è  c3 b4 ô
c2 a1 ¡  c2 ad ­  c2 b9 ¹  c3 85 Å  c3 91 Ñ  c3 9d Ý  c3 a9 é  c3 b5 õ
c2 a2 ¢  c2 ae ®  c2 ba º  c3 86 Æ  c3 92 Ò  c3 9e Þ  c3 aa ê  c3 b6 ö
c2 a3 £  c2 af ¯  c2 bb »  c3 87 Ç  c3 93 Ó  c3 9f ß  c3 ab ë  c3 b7 ÷
c2 a4 ¤  c2 b0 °  c2 bc ¼  c3 88 È  c3 94 Ô  c3 a0 à  c3 ac ì  c3 b8 ø
c2 a5 ¥  c2 b1 ±  c2 bd ½  c3 89 É  c3 95 Õ  c3 a1 á  c3 ad í  c3 b9 ù
c2 a6 ¦  c2 b2 ²  c2 be ¾  c3 8a Ê  c3 96 Ö  c3 a2 â  c3 ae î  c3 ba ú
c2 a7 §  c2 b3 ³  c2 bf ¿  c3 8b Ë  c3 97 ×  c3 a3 ã  c3 af ï  c3 bb û
c2 a8 ¨  c2 b4 ´  c3 80 À  c3 8c Ì  c3 98 Ø  c3 a4 ä  c3 b0 ð  c3 bc ü
c2 a9 ©  c2 b5 µ  c3 81 Á  c3 8d Í  c3 99 Ù  c3 a5 å  c3 b1 ñ  c3 bd ý
c2 aa ª  c2 b6 ¶  c3 82 Â  c3 8e Î  c3 9a Ú  c3 a6 æ  c3 b2 ò  c3 be þ
c2 ab «  c2 b7 ·  c3 83 Ã  c3 8f Ï  c3 9b Û  c3 a7 ç  c3 b3 ó  c3 bf ÿ
$
.RE
.fi
.PP
Use google base to extract information (Internet connection is required):
.PP
.nf
.RS 4
$ bh_websearch \-t file \-e txt \-d mentebinaria.com.br \-p 2
[ file ] IN mentebinaria.com.br txt
[+] 0
[+] 10
[+] 20
=============================================
mentebinaria.com.br/artigos/0x0a/gamevista.txt
mentebinaria.com.br/artigos/0x0b/virtlinux.txt
mentebinaria.com.br/artigos/0x0d/altexe.txt
\-\-passage omitted\-\-
$ bh_websearch \-t phone \-d XXX.com.br \-p 2
[ phone ] IN XXX.com.br
[+] 0
[+] 10
[+] 20
=============================================
(021) 55522635
(021) 55554601
(11) 5555\-8402
(11) 5555\-8927
(21) 5555\-4511
(21) 5555\-4632
(21) 55559400
$ bh_websearch \-t mail \-d XXX.com.br \-p 2
[ mail ] IN XXX.com.br
[+] 0
[+] 10
[+] 20
=============================================
XSX@XXX.com.br
XXxxXXXXXXXXXXXXX@XXX.com.br
Xad@XXX.com.br
cXXXXtXXXXXXXX@XXX.com.br
Xxx@XXX.com.br
XXXXXXXXXantana@XXX.com.br
eXc@XXX.com.br
XXX@XXX.com.br
XXX@XXX.com.br
XeX@XXX.com.br
XXX@XXX.com.br
joXXXXXXXXXX@XXX.com.br
$
.RE
.fi
.PP
Downloads all the pages (recursively) of a URL in continuous mode and with interval between each page randomized:
.PP
.nf
.RS 4
$ bh_wgetr http://www.mentebinaria.com.br
\-\-passage omitted\-\-
$ ls \-1 www.mentebinaria.com.br
index.html
robots.txt
style.css
\-\-passage omitted\-\-
$
.RE
.fi
.PP
Scan WiFi (root is required):
.PP
.nf
.RS 4
# bh_wscan
.PP
6	f8:1a:67:c2:be:0a	: \-55.00	: Hunter
10	9c:97:26:67:f0:4b	: \-87.00	: WiFi Fon
11	00:1a:3f:83:01:df	: \-86.00	: ZUDICA
.PP
# bh_wscan \-mac f8:1a:67:c2:be:0a
TP\-LINK TECHNOLOGIES CO., LTD.
# bh_wscan \-oui
BSS 00:1e:58:c4:e9:63 (on wlan0) \-\- associated
	     SSID: Barack
	     Vendor specific: OUI 00:03:7f, data: 01 01 00 20 ff 7f
		           * Model: DIR\-300
BSS 14:d6:4d:72:66:d4 (on wlan0)
	     SSID:
	     Vendor specific: OUI 00:0c:43, data: 00 00 00 00
# bh_wscan \-oui 00:03:7f
2015\-11\-06 20:44:19 URL:http://standards.ieee.org/cgi\-bin/ouisearch [1175] \-> "\-" [1]
===============================================================================
00\-90\-4C   (hex)                Epigram, Inc.
00904C     (base 16)            Epigram, Inc.
                                870 West Maude Ave.
                                Sunnyvale  CA  94086
                                US
# bh_wscan \-wps
 14:cc:20:09:8f:84       1      WPS 1.0
 64:70:02:62:9f:74       3      WPS 1.0
 e8:de:27:f0:fb:2e       4      WPS 0.0
 74:ea:3a:d2:3c:02       9      WPS 1.0
# bh_wscan \-model
 14:cc:20:09:8f:84               * TL\-WR841N
 e8:de:27:f0:fb:2e               * TD\-W8901N
#
.RE
.fi
.PP
Calculate exclusive OR between two numbers:
.PP
.nf
.RS 4
$ bh_xor 0xdead 0xdead
0
$ bh_xor 45 20
57
$
.RE
.fi
.PP
Show Excess\-3 table:
.PP
.nf
.RS 4
$ bh_xs3table
Dec Excess\-3
 \-3 0000
 \-2 0001
 \-1 0010
  0 0011
  1 0100
  2 0101
  3 0110
  4 0111
  5 1000
  6 1001
  7 1010
  8 1011
  9 1100
 10 1101
 11 1110
 12 1111
$
.RE
.fi
.PP
Compress a file with password "virus":
.PP
.nf
.RS 4
$ bh_zipmal bashacks.sh
  adding: bashacks.sh (deflated 69%)
\-rw\-r\-\-r\-\- 1 bashacks users 13K Dez 10 20:57 bashacks.zip
$ unzip bashacks.zip
Archive:  bashacks.zip
[bashacks.zip] bashacks.sh password:
  inflating: bashacks.sh
$
.RE
.fi
.PP
.\"
.SH AUTHORS
Written by Fernando Mercês and Wesley Henrique
.\"
.SH REPORTING BUGS
Please, check the latest development code and report at https://github.com/merces/bashacks/issues
.\"
.SH COPYRIGHT
Copyright © 2014 bashack authors. Licensed GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.
